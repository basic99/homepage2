<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<meta name="version" content="S5 1.1" />
<title>Python Web Programming</title>
<link rel="stylesheet" href="ui/uw_pce_theme/pretty.css" type="text/css" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<script src="ui/uw_pce_theme/slides.js" type="text/javascript"></script>
<link rel="stylesheet" href="ui/uw_pce_theme/slides.css"
      type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/uw_pce_theme/outline.css"
      type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/uw_pce_theme/print.css"
      type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/uw_pce_theme/opera.css"
      type="text/css" media="projection" id="operaFix" />
</head>
<body>
<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header">

</div>
<div id="footer">
<h1>Python Web Programming</h1>
<h2><a class="reference external" href="http://github.com/cewing/training.python_web">View document source</a>.
</h2>
</div>
</div>
<div class="presentation">
<div class="slide" id="slide0">
<h1 class="title">Python Web Programming</h1>

<img alt="img/python.png" class="align-left" src="img/python.png" style="width: 33%;" />
<p>Session 1: Networking and Sockets</p>
<p class="intro-blurb">Wherein we learn about the basic structure of the internet and explore the
building blocks that make it possible.</p>

</div>
<div class="slide" id="but-first">
<h1>But First</h1>
<p>Class presentations are available online for your use</p>
<p><a class="reference external" href="http://github.com/cewing/training.python_web">http://github.com/cewing/training.python_web</a></p>
<p>Use the <tt class="docutils literal"><span class="pre">week-long-format</span></tt> branch for this class</p>
<p>Licensed with Creative Commons BY-NC-SA</p>
<ul class="simple">
<li>You must attribute the work</li>
<li>You may not use the work for commercial purposes</li>
<li>You have to share your versions just like this one</li>
</ul>
<p>Find mistakes? See improvements? Make a pull request.</p>
</div>
<div class="slide" id="id1">
<h1>But First</h1>
<p>Daily Schedule</p>
<ul class="simple">
<li>9:00 am to 10:30 am - Session 1a</li>
<li>15 minute break</li>
<li>10:45 am to 12:30 pm - Session 1b</li>
<li>1 hour lunch</li>
<li>1:30 pm to 3:00 pm - Session 2a</li>
<li>15 minute break</li>
<li>3:15 pm to 5:00 pm - Session 2b</li>
</ul>
</div>
<div class="slide" id="id2">
<h1>But First</h1>
<p>Classroom Protocol</p>
<p class="incremental">Question to ask:</p>
<ul class="incremental simple">
<li>What did you just say?</li>
<li>Please explain what we just did again?</li>
<li>Why didn't that work for me?</li>
<li>Is that a typo?</li>
</ul>
</div>
<div class="slide" id="id3">
<h1>But First</h1>
<p>Classroom Protocol</p>
<p class="incremental">Question <strong>not</strong> to ask:</p>
<ul class="incremental simple">
<li>Hypotheticals: What happens if I do X?</li>
<li>Research: Can Python do Y?</li>
<li>Syllabus: Are we going to cover Z in class?</li>
<li>Marketing questions: please just don't.</li>
<li>Performance questions: Is Python fast enough?</li>
<li>Unpythonic: Why doesn't Python do it some other way?</li>
<li>Show off: Look what I just did!</li>
</ul>
</div>
<div class="slide" id="id4">
<h1>But First</h1>
<p class="big-centered">Introductions</p>
</div>
<div class="slide" id="computer-communications">
<h1>Computer Communications</h1>
<img alt="img/network_topology.png" class="align-left" src="img/network_topology.png" style="width: 40%;" />
<ul class="incremental simple">
<li>processes can communicate</li>
<li>inside one machine</li>
<li>between two machines</li>
<li>among many machines</li>
</ul>
<p class="image-credit">image: <a class="reference external" href="http://en.wikipedia.org/wiki/Internet_Protocol_Suite">http://en.wikipedia.org/wiki/Internet_Protocol_Suite</a></p>
</div>
<div class="slide" id="id5">
<h1>Computer Communications</h1>
<img alt="img/data_in_tcpip_stack.png" class="align-left" src="img/data_in_tcpip_stack.png" style="width: 55%;" />
<ul class="incremental simple">
<li>Process divided into 'layers'</li>
<li>'Layers' are mostly arbitrary</li>
<li>Different descriptions have different layers</li>
<li>Most common is the 'TCP/IP Stack'</li>
</ul>
<p class="image-credit">image: <a class="reference external" href="http://en.wikipedia.org/wiki/Internet_Protocol_Suite">http://en.wikipedia.org/wiki/Internet_Protocol_Suite</a></p>
</div>
<div class="slide" id="the-tcp-ip-stack-link">
<h1>The TCP/IP Stack - Link</h1>
<p>The bottom layer is the 'Link Layer'</p>
<ul class="incremental simple">
<li>Deals with the physical connections between machines, 'the wire'</li>
<li>Packages data for physical transport</li>
<li>Executes transmission over a physical medium<ul>
<li>what that medium is is arbitrary</li>
</ul>
</li>
<li>Primarily uses the Network Interface Card (NIC) in your computer</li>
</ul>
</div>
<div class="slide" id="the-tcp-ip-stack-internet">
<h1>The TCP/IP Stack - Internet</h1>
<p>Moving up, we have the 'Internet Layer'</p>
<ul class="incremental simple">
<li>Deals with addressing and routing<ul>
<li>Where are we going and how do we get there?</li>
</ul>
</li>
<li>Agnostic as to physical medium (IP over Avian Carrier - IPoAC)</li>
<li>Makes no promises of reliability</li>
<li>Two addressing systems<ul class="incremental">
<li>IPv4 (current, limited '192.168.1.100')</li>
<li>IPv6 (future, 3.4 x 10^38 addresses, '2001:0db8:85a3:0042:0000:8a2e:0370:7334')</li>
</ul>
</li>
</ul>
</div>
<div class="slide" id="id6">
<h1>The TCP/IP Stack - Internet</h1>
<p class="big-centered">That's 4.3 x 10^28 addresses <em>per person alive today</em></p>
</div>
<div class="slide" id="the-tcp-ip-stack-transport">
<h1>The TCP/IP Stack - Transport</h1>
<p>Next up is the 'Transport Layer'</p>
<ul class="incremental simple">
<li>Deals with transmission and reception of data<ul>
<li>error correction, flow control, congestion management</li>
</ul>
</li>
<li>Common protocols include TCP &amp; UDP<ul>
<li>TCP: Tranmission Control Protocol</li>
<li>UDP: User Datagram Protocol</li>
</ul>
</li>
<li>Not all Transport Protocols are 'reliable'<ul class="incremental">
<li>TCP ensures that dropped packets are resent</li>
<li>UDP makes no such assurance</li>
<li>Reliability is slow and expensive</li>
</ul>
</li>
</ul>
</div>
<div class="slide" id="id7">
<h1>The TCP/IP Stack - Transport</h1>
<p>The 'Transport Layer' also establishes the concept of a <strong>port</strong></p>
<ul class="incremental simple">
<li>IP Addresses designate a specific <em>machine</em> on the network</li>
<li>A <strong>port</strong> provides addressing for individual <em>applications</em> in a single host</li>
<li>192.168.1.100:80  (the <em>:80</em> part is the <strong>port</strong>)</li>
</ul>
<p class="incremental">This means that you don't have to worry about information intended for your
web browser being accidentally read by your email client.</p>
</div>
<div class="slide" id="id8">
<h1>The TCP/IP Stack - Transport</h1>
<p>There are certain <strong>ports</strong> which are commonly understood to belong to given
applications or protocols:</p>
<ul class="incremental simple">
<li>80/443 - HTTP/HTTPS</li>
<li>20 - FTP</li>
<li>22 - SSH</li>
<li>23 - Telnet</li>
<li>25 - SMTP</li>
<li>...</li>
</ul>
<p class="small">(see <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>)</p>
</div>
<div class="slide" id="id9">
<h1>The TCP/IP Stack - Transport</h1>
<p>Ports are grouped into a few different classes</p>
<ul class="incremental simple">
<li>Ports numbered 0 - 1023 are <em>reserved</em></li>
<li>Ports numbered 1024 - 65535 are <em>open</em></li>
<li>Ports numbered 49152 - 65535 are generally considered <em>ephemeral</em></li>
</ul>
</div>
<div class="slide" id="the-tcp-ip-stack-application">
<h1>The TCP/IP Stack - Application</h1>
<p>The topmost layer is the 'Application Layer'</p>
<ul class="incremental simple">
<li>Deals directly with data produced or consumed by an application</li>
<li>Reads or writes data using a set of understood, well-defined <strong>protocols</strong><ul>
<li>HTTP, SMTP, FTP etc.</li>
</ul>
</li>
<li>Does not know (or need to know) about lower layer functionality<ul>
<li>The exception to this rule is <strong>endpoint</strong> data (or IP:Port)</li>
</ul>
</li>
</ul>
</div>
<div class="slide" id="id10">
<h1>The TCP/IP Stack - Application</h1>
<p class="big-centered">this is where we live and work</p>
</div>
<div class="slide" id="sockets">
<h1>Sockets</h1>
<p>Think back for a second to what we just finished discussing, the TCP/IP stack.</p>
<ul class="incremental simple">
<li>The <em>Internet</em> layer gives us an <strong>IP Address</strong></li>
<li>The <em>Transport</em> layer establishes the idea of a <strong>port</strong>.</li>
<li>The <em>Application</em> layer doesn't care about what happens below...</li>
<li><em>Except for</em> <strong>endpoint data</strong> (IP:Port)</li>
</ul>
<p class="incremental">A <strong>Socket</strong> is the software representation of that endpoint.</p>
<p class="incremental">Opening a <strong>socket</strong> creates a kind of transceiver that can send and/or
receive data at a given IP address and Port.</p>
</div>
<div class="slide" id="sockets-in-python">
<h1>Sockets in Python</h1>
<p>Python provides a standard library module which provides socket functionality.
It is called <strong>socket</strong>.  Let's spend a few minutes getting to know this
module.</p>
<p>We're going to do this next part together, so open up a terminal and start a
python interpreter</p>
</div>
<div class="slide" id="id11">
<h1>Sockets in Python</h1>
<p>The sockets library provides tools for finding out information about hosts on
the network. For example, you can find out about the machine you are currently
using:</p>
<pre class="literal-block">
&gt;&gt;&gt; import socket
&gt;&gt;&gt; socket.gethostname()
'heffalump.local'
&gt;&gt;&gt; socket.gethostbyname(socket.gethostname())
'10.211.55.2'
</pre>
</div>
<div class="slide" id="id12">
<h1>Sockets in Python</h1>
<p>You can also find out about machines that are located elsewhere, assuming you
know their hostname. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; socket.gethostbyname('google.com')
'173.194.33.4'
&gt;&gt;&gt; socket.gethostbyname('unc.edu')
'152.19.240.120'
&gt;&gt;&gt; socket.gethostbyname('crisewing.com')
'108.59.11.99'
</pre>
</div>
<div class="slide" id="id13">
<h1>Sockets in Python</h1>
<p>The <tt class="docutils literal">gethostbyname_ex</tt> method of the <tt class="docutils literal">socket</tt> library provides more
information about the machines we are exploring:</p>
<pre class="literal-block">
&gt;&gt;&gt; socket.gethostbyname_ex('google.com')
('google.com', [], ['173.194.33.9', '173.194.33.14',
                    ...
                    '173.194.33.6', '173.194.33.7',
                    '173.194.33.8'])
&gt;&gt;&gt; socket.gethostbyname_ex('crisewing.com')
('crisewing.com', [], ['108.59.11.99'])
&gt;&gt;&gt; socket.gethostbyname_ex('www.rad.washington.edu')
('elladan.rad.washington.edu', # &lt;- canonical hostname
 ['www.rad.washington.edu'], # &lt;- any machine aliases
 ['128.95.247.84']) # &lt;- all active IP addresses
</pre>
</div>
<div class="slide" id="id14">
<h1>Sockets in Python</h1>
<p>To create a socket, you use the <strong>socket</strong> method of the <tt class="docutils literal">socket</tt> library.
It takes up to three optional positional arguments (here we use none to get
the default behavior):</p>
<pre class="literal-block">
&gt;&gt;&gt; foo = socket.socket()
&gt;&gt;&gt; foo
&lt;socket._socketobject object at 0x10046cec0&gt;
</pre>
</div>
<div class="slide" id="id15">
<h1>Sockets in Python</h1>
<p>A socket has some properties that are immediately important to us. These
include the <em>family</em>, <em>type</em> and <em>protocol</em> of the socket:</p>
<pre class="literal-block">
&gt;&gt;&gt; foo.family
2
&gt;&gt;&gt; foo.type
1
&gt;&gt;&gt; foo.proto
0
</pre>
<p class="incremental">You might notice that the values for these properties are integers.  In fact,
these integers are <strong>constants</strong> defined in the socket library.</p>
</div>
<div class="slide" id="a-quick-utility-method">
<h1>A quick utility method</h1>
<p>Let's define a method in place to help us see these constants. It will take a
single argument, the shared prefix for a defined set of constants:</p>
<pre class="small literal-block">
&gt;&gt;&gt; def get_constants(prefix):
...     &quot;&quot;&quot;mapping of socket module constants to their names.&quot;&quot;&quot;
...     return dict( (getattr(socket, n), n)
...                  for n in dir(socket)
...                  if n.startswith(prefix)
...                  )
...
&gt;&gt;&gt;
</pre>
</div>
<div class="slide" id="socket-families">
<h1>Socket Families</h1>
<p>Think back a moment to our discussion of the <em>Internet</em> layer of the TCP/IP
stack.  There were a couple of different types of IP addresses:</p>
<ul class="incremental simple">
<li>IPv4 ('192.168.1.100')</li>
<li>IPv6 ('2001:0db8:85a3:0042:0000:8a2e:0370:7334')</li>
</ul>
<p class="incremental">The <em>family</em> of a socket corresponds to the addressing system it uses for
connecting.</p>
</div>
<div class="slide" id="id16">
<h1>Socket Families</h1>
<p>Families defined in the <tt class="docutils literal">socket</tt> library are prefixed by <tt class="docutils literal">AF_</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; families = get_constants('AF_')
&gt;&gt;&gt; families
{0: 'AF_UNSPEC', 1: 'AF_UNIX', 2: 'AF_INET',
 11: 'AF_SNA', 12: 'AF_DECnet', 16: 'AF_APPLETALK',
 17: 'AF_ROUTE', 23: 'AF_IPX', 30: 'AF_INET6'}
</pre>
<p class="small incremental"><em>Your results may vary</em></p>
<p class="incremental">Of all of these, the ones we care most about are <tt class="docutils literal">2</tt> (IPv4) and <tt class="docutils literal">30</tt> (IPv6).</p>
</div>
<div class="slide" id="unix-domain-sockets">
<h1>Unix Domain Sockets</h1>
<p>When you are on a machine with an operating system that is Unix-like, you will
find another generally useful socket family: <tt class="docutils literal">AF_UNIX</tt>, or Unix Domain
Sockets. Sockets in this family:</p>
<ul class="incremental simple">
<li>connect processes <strong>on the same machine</strong></li>
<li>are generally a bit slower than IPC connnections</li>
<li>have the benefit of allowing the same API for programs that might run on one
machine __or__ across the network</li>
<li>use an 'address' that looks like a pathname ('/tmp/foo.sock')</li>
</ul>
</div>
<div class="slide" id="test-your-skills">
<h1>Test your skills</h1>
<p>What is the <em>default</em> family for the socket we created just a moment ago?</p>
<p class="incremental">(remember we bound the socket to the symbol <tt class="docutils literal">foo</tt>)</p>
</div>
<div class="slide" id="socket-types">
<h1>Socket Types</h1>
<p>The socket <em>type</em> determines the semantics of socket communications.</p>
<p>Look up socket type constants with the <tt class="docutils literal">SOCK_</tt> prefix:</p>
<pre class="literal-block">
&gt;&gt;&gt; types = get_constants('SOCK_')
&gt;&gt;&gt; types
{1: 'SOCK_STREAM', 2: 'SOCK_DGRAM',
 ...}
</pre>
<p class="incremental">The most common are <tt class="docutils literal">1</tt> (TCP type communication) and <tt class="docutils literal">2</tt> (UDP type
communication).</p>
</div>
<div class="slide" id="id17">
<h1>Test your skills</h1>
<p>What is the <em>default</em> type for our generic socket, <tt class="docutils literal">foo</tt>?</p>
</div>
<div class="slide" id="socket-protocols">
<h1>Socket Protocols</h1>
<p>A socket also has a designated <em>protocol</em>. The constants for these are
prefixed by <tt class="docutils literal">IPPROTO_</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; protocols = get_constants('IPPROTO_')
&gt;&gt;&gt; protocols
{0: 'IPPROTO_IP', 1: 'IPPROTO_ICMP',
 ...,
 255: 'IPPROTO_RAW'}
</pre>
<p class="incremental">The choice of which protocol to use for a socket is determined by the
communications protocol you intend to use.  <tt class="docutils literal">IP</tt>? <tt class="docutils literal">ICMP</tt>? <tt class="docutils literal">UDP</tt>?</p>
</div>
<div class="slide" id="id18">
<h1>Test your skills</h1>
<p>What is the <em>default</em> protocol used by our generic socket, <tt class="docutils literal">foo</tt>?</p>
</div>
<div class="slide" id="address-information">
<h1>Address Information</h1>
<p>These three properties of a socket correspond to the three positional arguments
you may pass to the constructor.  This allows you to create sockets that have
specific communications profiles:</p>
<pre class="literal-block">
&gt;&gt;&gt; bar = socket.socket(socket.AF_INET,
...                     socket.SOCK_DGRAM,
...                     socket.IPPROTO_UDP)
...
&gt;&gt;&gt; bar
&lt;socket._socketobject object at 0x1005b8b40&gt;
</pre>
</div>
<div class="slide" id="id19">
<h1>Address Information</h1>
<p>But when you are creating a socket to communicate with a remote service, how
can you determine the <em>correct</em> values to use?</p>
<p class="incremental">You ask.</p>
</div>
<div class="slide" id="client-connections">
<h1>Client Connections</h1>
<p>The information returned by a call to <tt class="docutils literal">socket.getaddrinfo</tt> is all you need
to make a proper connection to a socket on a remote host.  The value returned
is a tuple of</p>
<ul class="incremental simple">
<li>socket family</li>
<li>socket type</li>
<li>socket protocol</li>
<li>canonical name (usually empty, unless requested by flag)</li>
<li>socket address (tuple of IP and Port)</li>
</ul>
</div>
<div class="slide" id="id20">
<h1>A quick utility method</h1>
<p>Again, let's create a utility method in-place so we can see this in action:</p>
<pre class="literal-block">
&gt;&gt;&gt; def get_address_info(host, port):
...     for response in socket.getaddrinfo(host, port):
...         fam, typ, pro, nam, add = response
...         print 'family: ', families[fam]
...         print 'type: ', types[typ]
...         print 'protocol: ', protocols[pro]
...         print 'canonical name: ', nam
...         print 'socket address: ', add
...         print
...
&gt;&gt;&gt;
</pre>
</div>
<div class="slide" id="on-your-own-machine">
<h1>On Your Own Machine</h1>
<p>Now, ask your own machine what services are available on 'http':</p>
<pre class="literal-block">
&gt;&gt;&gt; get_address_info(socket.gethostname(), 'http')
family:  AF_INET
type:  SOCK_DGRAM
protocol:  IPPROTO_UDP
canonical name:
socket address:  ('10.211.55.2', 80)

family:  AF_INET
...
&gt;&gt;&gt;
</pre>
<p class="incremental">What answers do you get?</p>
</div>
<div class="slide" id="on-the-internet">
<h1>On the Internet</h1>
<pre class="literal-block">
&gt;&gt;&gt; get_address_info('crisewing.com', 'http')
family:  AF_INET
type:  SOCK_DGRAM
...

family:  AF_INET
type:  SOCK_STREAM
...
&gt;&gt;&gt;
</pre>
<p class="incremental">Try a few other servers you know about.</p>
</div>
<div class="slide" id="first-steps">
<h1>First Steps</h1>
<p class="big-centered">Let's put this to use</p>
</div>
<div class="slide" id="construct-a-socket">
<h1>Construct a Socket</h1>
<p>We've already made a socket <tt class="docutils literal">foo</tt> using the generic constructor without any
arguments.  We can make a better one now by using real address information from
a real server online:</p>
<pre class="small literal-block">
&gt;&gt;&gt; streams = [info
...     for info in socket.getaddrinfo('crisewing.com', 'http')
...     if info[1] == socket.SOCK_STREAM]
&gt;&gt;&gt; streams
[(2, 1, 6, '', ('108.59.11.99', 80))]
&gt;&gt;&gt; info = streams[0]
&gt;&gt;&gt; cewing_socket = socket.socket(*info[:3])
</pre>
</div>
<div class="slide" id="connecting-a-socket">
<h1>Connecting a Socket</h1>
<p>Once the socket is constructed with the appropriate <em>family</em>, <em>type</em> and
<em>protocol</em>, we can connect it to the address of our remote server:</p>
<pre class="literal-block">
&gt;&gt;&gt; cewing_socket.connect(info[-1])
&gt;&gt;&gt;
</pre>
<ul class="incremental simple">
<li>a successful connection returns <tt class="docutils literal">None</tt></li>
<li>a failed connection raises an error</li>
<li>you can use the <em>type</em> of error returned to tell why the connection failed.</li>
</ul>
</div>
<div class="slide" id="sending-a-message">
<h1>Sending a Message</h1>
<p>Send a message to the server on the other end of our connection (we'll
learn is session 2 about the message we are sending):</p>
<pre class="literal-block">
&gt;&gt;&gt; msg = &quot;GET / HTTP/1.1\r\n&quot;
&gt;&gt;&gt; msg += &quot;Host: crisewing.com\r\n\r\n&quot;
&gt;&gt;&gt; cewing_socket.sendall(msg)
&gt;&gt;&gt;
</pre>
<ul class="incremental small simple">
<li>the transmission continues until all data is sent or an error occurs</li>
<li>success returns <tt class="docutils literal">None</tt></li>
<li>failure to send raises an error</li>
<li>you can use the type of error to figure out why the transmission failed</li>
<li>you <strong>cannot</strong> know how much, if any, of your data was sent</li>
</ul>
</div>
<div class="slide" id="receiving-a-reply">
<h1>Receiving a Reply</h1>
<p>Whatever reply we get is received by the socket we created. We can read it
back out:</p>
<pre class="literal-block">
&gt;&gt;&gt; response = cewing_socket.recv(4096)
&gt;&gt;&gt; response
'HTTP/1.1 200 OK\r\nDate: Thu, 03 Jan 2013 05:56:53
...
</pre>
<ul class="incremental small simple">
<li>The sole required argument is <tt class="docutils literal">buffer_size</tt> (an integer). It should be a
power of 2 and smallish</li>
<li>It returns a byte string of <tt class="docutils literal">buffer_size</tt> (or smaller if less data was
received)</li>
<li>If the response is longer than <tt class="docutils literal">buffer size</tt>, you can call the method
repeatedly. The last bunch will be less than <tt class="docutils literal">buffer size</tt>.</li>
</ul>
</div>
<div class="slide" id="cleaning-up">
<h1>Cleaning Up</h1>
<p>When you are finished with a connection, you should always close it:</p>
<pre class="literal-block">
&gt;&gt;&gt; cewing_socket.close()
</pre>
</div>
<div class="slide" id="putting-it-all-together">
<h1>Putting it all together</h1>
<p>First, connect and send a message:</p>
<pre class="literal-block">
&gt;&gt;&gt; streams = [info
...     for info in socket.getaddrinfo('crisewing.com', 'http')
...     if info[1] == socket.SOCK_STREAM]
&gt;&gt;&gt; info = streams[0]
&gt;&gt;&gt; cewing_socket = socket.socket(*info[:3])
&gt;&gt;&gt; cewing_socket.connect(info[-1])
&gt;&gt;&gt; msg = &quot;GET / HTTP/1.1\r\n\r\n&quot;
&gt;&gt;&gt; msg += &quot;Host: crisewing.com\r\n\r\n&quot;
&gt;&gt;&gt; cewing_socket.sendall(msg)
</pre>
</div>
<div class="slide" id="id21">
<h1>Putting it all together</h1>
<p>Then, receive a reply, iterating until it is complete:</p>
<pre class="literal-block">
&gt;&gt;&gt; buffsize = 4096
&gt;&gt;&gt; response = ''
&gt;&gt;&gt; done = False
&gt;&gt;&gt; while not done:
...     msg_part = cewing_socket.recv(buffsize)
...     if len(msg_part) &lt; buffsize:
...         done = True
...         cewing_socket.close()
...     response += msg_part
&gt;&gt;&gt; len(response)
19427
</pre>
</div>
<div class="slide" id="break-time">
<h1>Break Time</h1>
<p>So far we have:</p>
<ul class="incremental simple">
<li>learned about the &quot;layers&quot; of the TCP/IP Stack</li>
<li>discussed <em>families</em>, <em>types</em> and <em>protocols</em> in sockets</li>
<li>learned some API for finding out how to connect to a remote server</li>
<li>made our first connection to a server</li>
<li>and sent and received our first messages through a socket.</li>
</ul>
<p class="incremental">Not bad for a Monday morning.</p>
<p class="incremental">Let's take 10 minutes and return to learn about the other end of this wire.</p>
</div>
<div class="slide" id="server-side">
<h1>Server Side</h1>
<p class="big-centered">What about the other half of the equation?</p>
</div>
<div class="slide" id="id22">
<h1>Construct a Socket</h1>
<p><strong>For the moment, stop typing this into your interpreter.</strong></p>
<div class="incremental container">
<p>Again, we begin by constructing a socket. Since we are actually the server
this time, we get to choose family, type and protocol:</p>
<pre class="literal-block">
&gt;&gt;&gt; server_socket = socket.socket(
...     socket.AF_INET,
...     socket.SOCK_STREAM,
...     socket.IPPROTO_IP)
...
&gt;&gt;&gt; server_socket
&lt;socket._socketobject object at 0x100563c90&gt;
</pre>
</div>
</div>
<div class="slide" id="bind-the-socket">
<h1>Bind the Socket</h1>
<p>Our server socket needs to be bound to an address. This is the IP Address and
Port to which clients must connect:</p>
<pre class="literal-block">
&gt;&gt;&gt; address = ('127.0.0.1', 50000)
&gt;&gt;&gt; server_socket.bind(address)
</pre>
<p class="incremental"><strong>Terminology Note</strong>: In a server/client relationship, the server <em>binds</em> to
an address and port. The client <em>connects</em></p>
</div>
<div class="slide" id="listen-for-connections">
<h1>Listen for Connections</h1>
<p>Once our socket is bound to an address, we can listen for attempted
connections:</p>
<pre class="literal-block">
&gt;&gt;&gt; server_socket.listen(1)
</pre>
<ul class="incremental simple">
<li>The argument to <tt class="docutils literal">listen</tt> is the <em>backlog</em></li>
<li>The <em>backlog</em> is the <strong>maximum</strong> number of connections that the socket will
queue</li>
<li>Once the limit is reached, the socket refuses new connections</li>
</ul>
</div>
<div class="slide" id="accept-incoming-messages">
<h1>Accept Incoming Messages</h1>
<p>When a socket is listening, it can receive incoming messages:</p>
<pre class="literal-block">
&gt;&gt;&gt; connection, client_address = server_socket.accept()
... # this blocks until a client connects
&gt;&gt;&gt; connection.recv(16)
</pre>
<ul class="incremental simple">
<li>The <tt class="docutils literal">connection</tt> returned by a call to <tt class="docutils literal">accept</tt> is a <strong>new socket</strong></li>
<li>It is this <em>new</em> socket that is used for communications with the client
socket</li>
<li>the <tt class="docutils literal">client_address</tt> is a two-tuple of IP Address and Port for the client
socket</li>
<li>The number of <em>new</em> sockets that can be spun off by a listening socket is
equal to <tt class="docutils literal">backlog</tt></li>
</ul>
</div>
<div class="slide" id="send-a-reply">
<h1>Send a Reply</h1>
<p>The same socket that received a message from the client may be used to return
a reply:</p>
<pre class="literal-block">
&gt;&gt;&gt; connection.sendall(&quot;message received&quot;)
</pre>
</div>
<div class="slide" id="clean-up">
<h1>Clean Up</h1>
<p>Once a transaction between the client and server is complete, the
<tt class="docutils literal">connection</tt> socket should be closed:</p>
<pre class="literal-block">
&gt;&gt;&gt; connection.close()
</pre>
<ul class="incremental simple">
<li>Closing the connection socket will decrement the number of active sockets in
the queue</li>
<li>If the maximum specified by <tt class="docutils literal">backlog</tt> had been reached, this will allow a
new connection to be made.</li>
</ul>
</div>
<div class="slide" id="getting-the-flow">
<h1>Getting the Flow</h1>
<p>The flow of this interaction can be a bit confusing.  Let's see it in action
step-by-step.</p>
<p class="incremental">Open a second python interpreter and place it next to your first so you can
see both of them at the same time.</p>
</div>
<div class="slide" id="create-a-server">
<h1>Create a Server</h1>
<p>In your first python interpreter, create a server socket and prepare it for
connections:</p>
<pre class="literal-block">
&gt;&gt;&gt; server_socket = socket.socket(
...     socket.AF_INET,
...     socket.SOCK_STREAM,
...     socket.IPPROTO_IP)
&gt;&gt;&gt; server_socket.bind(('127.0.0.1', 50000))
&gt;&gt;&gt; server_socket.listen(1)
&gt;&gt;&gt; conn, addr = server_socket.accept()
</pre>
<p class="incremental">At this point, you should <strong>not</strong> get back a prompt. The server socket is
waiting for a connection to be made.</p>
</div>
<div class="slide" id="create-a-client">
<h1>Create a Client</h1>
<p>In your second interpreter, create a client socket and prepare to send a
message:</p>
<pre class="literal-block">
&gt;&gt;&gt; import socket
&gt;&gt;&gt; client_socket = socket.socket(
...     socket.AF_INET
...     socket.SOCK_STREAM,
...     socket.IPPROTO_IP)
</pre>
<div class="incremental container">
<p>Before connecting, keep your eye on the server interpreter:</p>
<pre class="literal-block">
&gt;&gt;&gt; client_socket.connect(('127.0.0.1', 50000))
</pre>
</div>
</div>
<div class="slide" id="send-a-message-client-server">
<h1>Send a Message Client-&gt;Server</h1>
<p>As soon as you made the connection above, you should have seen the prompt
return in your server interpreter. The <tt class="docutils literal">accept</tt> method finally returned a
new connection socket.</p>
<p class="incremental">When you're ready, type the following in the <em>client</em> interpreter. Watch the
server!</p>
<pre class="incremental literal-block">
&gt;&gt;&gt; client_socket.sendall(&quot;Hey, can you hear me?&quot;)
</pre>
</div>
<div class="slide" id="receive-and-respond">
<h1>Receive and Respond</h1>
<p>Back in your server interpreter, go ahead and receive the message from your
client:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.receive(32)
'Hey, can you hear me?'
</pre>
<p>Send a message back, and then close up your connection:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.sendall(&quot;Yes, I hear you.&quot;)
&gt;&gt;&gt; conn.close()
</pre>
</div>
<div class="slide" id="finish-up">
<h1>Finish Up</h1>
<p>Back in your client interpreter, take a look at the response to your message,
then be sure to close your client socket too:</p>
<pre class="literal-block">
&gt;&gt;&gt; client_socket.recv(32)
'Yes, I hear you.'
&gt;&gt;&gt; client_socket.close()
</pre>
<p>And now that we're done, we can close up the server too (back in the server
iterpreter):</p>
<pre class="literal-block">
&gt;&gt;&gt; server_socket.close()
</pre>
</div>
<div class="slide" id="congratulations">
<h1>Congratulations!</h1>
<p class="big-centered">You've run your first client-server interaction</p>
</div>
<div class="slide" id="take-it-to-the-next-level">
<h1>Take it to the Next Level</h1>
<p>That's pretty much everything we need to build a simple echo server and
client.</p>
<p class="incremental">We are now going to move to writing python files.</p>
<p class="incremental">Quit both interpreters and open a new file in your favorite text editor.  Call
it <tt class="docutils literal">echo_client.py</tt></p>
</div>
<div class="slide" id="the-echo-client-1">
<h1>The Echo Client - 1</h1>
<pre class="code python small literal-block">
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">client</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;sending: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">msg</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">usg</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n</span><span class="s">usage: python echo_client.py &quot;this is my message&quot;</span><span class="se">\n</span><span class="s">'</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">usg</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">client</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre>
<p class="incremental">Save that and try it out</p>
</div>
<div class="slide" id="check-your-work">
<h1>Check Your Work</h1>
<p>In your terminal, where you created and saved <tt class="docutils literal">echo_client.py</tt>:</p>
<pre class="literal-block">
$ python echo_client.py

usage: python echo_client.py &quot;this is my message&quot;

$ python echo_client.py &quot;my baloney has a first name&quot;
sending &quot;my baloney has a first name&quot;
</pre>
</div>
<div class="slide" id="the-echo-client-2">
<h1>The Echo Client - 2</h1>
<pre class="code python small literal-block">
<span class="k">def</span> <span class="nf">client</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s">'localhost'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'connecting to </span><span class="si">%s</span><span class="s"> port </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">server_address</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># Send data</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'sending &quot;</span><span class="si">%s</span><span class="s">&quot;'</span> <span class="o">%</span> <span class="n">msg</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c"># Look for the response</span>
        <span class="n">amount_received</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">amount_expected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">amount_received</span> <span class="o">&lt;</span> <span class="n">amount_expected</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">amount_received</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'received &quot;</span><span class="si">%s</span><span class="s">&quot;'</span> <span class="o">%</span> <span class="n">data</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'closing socket'</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
</div>
<div class="slide" id="it-takes-two">
<h1>It Takes Two</h1>
<p>The client script at this point is no good without a server to receive the
message and send it back.  Let's make that next.</p>
<p class="incremental">Again, open a new file in your text editor.  Call it <cite>echo_server.py</cite>.</p>
</div>
<div class="slide" id="the-echo-server-1">
<h1>The Echo Server - 1</h1>
<pre class="code python small literal-block">
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">server</span><span class="p">():</span>
    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="s">'127.0.0.1'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;making a server on </span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">address</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">pass</span> <span class="c">#&lt;- what goes here comes in the next slide</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">server</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre>
</div>
<div class="slide" id="the-echo-server-2">
<h1>The Echo Server - 2</h1>
<pre class="code python small literal-block">
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'waiting for a connection'</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span> <span class="c"># blocking</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'connection - </span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">addr</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
                <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">'received &quot;</span><span class="si">%s</span><span class="s">&quot;'</span> <span class="o">%</span> <span class="n">data</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">'sending data back to client'</span>
                    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">msg</span>
                    <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">'no more data from </span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">addr</span>
                    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">msg</span>
                    <span class="k">break</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
    <span class="c"># ...</span>
</pre>
</div>
<div class="slide" id="playing-with-your-toy">
<h1>Playing With Your Toy</h1>
<p>In one terminal, start the server:</p>
<pre class="literal-block">
$ python echo_server.py
making a server on 127.0.0.1:10000
waiting for a connection
</pre>
<p class="incremental">In a second, use the client to send a message:</p>
<pre class="incremental literal-block">
$ python echo_client.py &quot;I am sending a longer message.&quot;
</pre>
</div>
<div class="slide" id="next-steps">
<h1>Next Steps</h1>
<p>You've now seen the basics of socket-based communication.</p>
<p class="incremental">In the next session, we'll learn about the protocols that govern these types
of communications.</p>
<p class="incremental">As an exercise, we'll extend this simple echo server into a basic HTTP
server, and we'll be able to ditch the client and use a web browser instead.</p>
</div>
<div class="slide" id="lunch-time">
<h1>Lunch Time</h1>
<p class="big-centered">We'll see you back here in an hour.  Enjoy!</p>
</div>
</div>
</body>
</html>
